<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 대진!</title>
    <link>https://daejinseok.github.io/post/</link>
    <description>Recent content in Posts on 대진!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Sun, 01 Jun 2014 00:00:00 +0900</lastBuildDate>
    <atom:link href="https://daejinseok.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>스니핏(snippet)</title>
      <link>https://daejinseok.github.io/post/2014-06-01-subl-snippet/</link>
      <pubDate>Sun, 01 Jun 2014 00:00:00 +0900</pubDate>
      
      <guid>https://daejinseok.github.io/post/2014-06-01-subl-snippet/</guid>
      <description>

&lt;p&gt;보통 스니핏(Snippet)이라고 하면 &amp;lsquo;코드조각&amp;rsquo;이라고 불리거나 혹은 재사용 가능한 짧은 코드를 의미하지만, 일반적인 텍스트 에디터에서는 정해진 단어를 입력해 사전에 입력된 코드들이 나타나도록 하는 기능을 의미합니다. 단순한 기능이지만 잘 활용하면 빠르고 정확한 텍스트를 입력할 수 있으며, 심지어 기억력을 보강해주는 효과도 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 많은 개발자가 이 기능을 잘 사용하지 않습니다. 이 기능의 존재를 모르거나, 알더라도 사용하기 불편하기 때문입니다. 그래서 기본적으로 작성된 스니핏 혹은 기존에 누군가 작성한 것을 사용하는 것이 보통입니다.&lt;/p&gt;

&lt;p&gt;이 글에서는 Sublime Text의 스니핏 기능이 얼마나 편리하게 사용할 수 있는지 보여줄 것이며, 스니핏으로 어떠한 기능까지 가능한지 혹은 한계는 무엇인지 알아보고자 합니다.&lt;/p&gt;

&lt;h4 id=&#34;명령목록에-new-snippet-등록하기&#34;&gt;명령목록에 &amp;lsquo;New Snippet&amp;rsquo; 등록하기&lt;/h4&gt;

&lt;p&gt;스니핏을 살펴보기 전에 명령목록에 &amp;lsquo;New Snippet&amp;rsquo;를 등록하면 매번 메뉴를 누르는 것 보다 더 편리하게 접근할 수 있습니다. 기본적으로는 등록되어 있지않으며, 메뉴에서는 [Tools] 가장 아래에 위치해 있습니다.&lt;/p&gt;

&lt;p&gt;원하는 파일명을 정하고 확장자는 반드시 *.sublime-commands*로 해야 합니다. 저는 보통 daejin.sublime-commands로 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    { &amp;quot;caption&amp;quot;: &amp;quot;New Snippet&amp;quot;, &amp;quot;command&amp;quot;: &amp;quot;new_snippet&amp;quot; }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 파일(다음부터는 &amp;lsquo;명령목록 파일&amp;rsquo;이라고 부르고 싶네요.)을 생성 후 sublime text의 패키지 디렉토리로 이동시키면 명령목록에서 &amp;lsquo;New Snippet&amp;rsquo;사용이 가능해 집니다.&lt;/p&gt;

&lt;p&gt;패지키 디렉토리로 가는 간단한 방법은 명령목록에서 &amp;lsquo;Preferences Browse Packages&amp;rsquo;를 선택하면 패키지 폴더가 나타나며, 여기에 위에서 작성한 파일을 옮겨 놓으면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/subl-001-snippet-1.png&#34; alt=&#34;Browse Packages&#34; /&gt;&lt;/p&gt;

&lt;p&gt;짜잔! 이제 여러분도 명령목록에서 &amp;lsquo;New Snippet&amp;rsquo; 사용하거나 혹은 여러분이 원하는 명령을 추가할 수 있게 되었네요. ^^&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/subl-001-snippet-2.png&#34; alt=&#34;New Snippet&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>팁3. 일보 후퇴 삼보 전진</title>
      <link>https://daejinseok.github.io/post/2014-05-31-pvim-104-tip3-take_one_step_back_then_three_forward/</link>
      <pubDate>Sat, 31 May 2014 00:00:00 +0900</pubDate>
      
      <guid>https://daejinseok.github.io/post/2014-05-31-pvim-104-tip3-take_one_step_back_then_three_forward/</guid>
      <description>

&lt;p&gt;원문 &lt;a href=&#34;http://media.pragprog.com/titles/dnvim/vim.pdf&#34;&gt;Practical Vim - The Vim Way&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Vim에서 문자의 앞뒤로 공백을 간단히 추가할 수 있습니다. 처음에는 이 방 법이 조금 이상해 보이지만, 반복할 수 있다는 장점이 있습니다. 우리는 다음의 작업을 어려움 없이 처리 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;아래와 같은 코드를 살펴봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var foo=&amp;quot;method(&amp;quot;+argument1+&amp;quot;,&amp;quot;+argument2+&amp;quot;)&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;약간 짜증나게 문자들이 연결되어 있습니다. 하지만 아래처럼 +기호 사이 각각에 공백을 추가하면 덜 짜증나게 될 것 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var foo=&amp;quot;method(&amp;quot; + argument1 + &amp;quot;,&amp;quot; + argument2 + &amp;quot;)&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;반복-가능한-변경-만들기&#34;&gt;반복 가능한 변경 만들기&lt;/h4&gt;

&lt;p&gt;일반적인 접근방법으로 해보면 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/pvim-004-tip3-1.png&#34; alt=&#34;점명령 + 예제&#34; /&gt;&lt;/p&gt;

&lt;p&gt;*s*명령은 커서 아래의 문자를 지우고 입력모드로 들어가는 두 가지 명령을 하나로 합친 명령입니다. *s*명령을 이용하여 +기호를 삭제하고 입력모드로 들어간 후, _+_를 입력하고 *&amp;lt;ESC&amp;gt;*를 눌러 입력모드에서 나옵니다.&lt;/p&gt;

&lt;p&gt;일보 후퇴 삼보 전진. 멀쩡한 +를 지우고, 다시 입력하는 것이 조금은 엉뚱해 보이지만 점명령을 사용할 수 있도록 반복가능한 변경을 만드는 것이 중요하며, 이로 인해 효과적인 편집이 가능해집니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;대진왈 : 이 예제에서는 수정전 문자와 수정후 문자가 동일한 +기호로 조금 혼란이 생기는데, 실제 많은 에디터에서 구현되어 있는 &amp;lsquo;교체하기(Replace)&amp;lsquo;와 비슷한 동작을 한 것입니다. 그리고 선택된 영역 혹은 특정영역만 교체하는 기능이 있는 에디터의 기능과 더욱 유사하겠네요. sublime text에서는 멀티커서의 개념으로 조금 직관적으로 비주얼하게 처리 가능합니다. 따라서 vim의 장점이 딱히 느껴지지 않지만 여러분의 손은 평션키나 마우스는 누르지 않고 원래의 위치에 고대로 있다는 사실을 알려주고 싶네요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;반복-가능한-이동-만들기&#34;&gt;반복 가능한 이동 만들기&lt;/h4&gt;

&lt;p&gt;이 예제에서는 또 다른 기법이 하나 더 있습니다. *f{문자}*명령은 f를 입력한 후에 하나의 문자가 입력되면 현재 커서의 위치 다음부터 해당 문자가 있는 곳으로 이동합니다( &lt;em&gt;:h f&lt;/em&gt; 참조 ). 그래서 *f+*를 입력하면, 커서는 다음 위치의 +기호로 바로 이동합니다. *f{문자}*에 대한 명령은 팁49에서 더 자세히 설명합니다.&lt;/p&gt;

&lt;p&gt;첫 수정하고, 우리는 *f+*를 반복하여 다음 위치로 점프할 수 있지만, 더 좋은 방법이 있습니다. *;명령*은 *f명령*으로 수행한 마지막 찾기를 반복합니다. 그래서 *f+*를 4번 입력하는 대신에 우리는 *f명령*을 한번 사용하고 *;명령*을 3번 사용할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&#34;이제-한꺼번에-해봅시다&#34;&gt;이제 한꺼번에 해봅시다.&lt;/h4&gt;

&lt;p&gt;*;명령*은 다음 작업할 위치로 데려다 주며, *.명령*은 마지막 변경된 작업을 반복합니다. 그래서 &lt;em&gt;;.&lt;/em&gt; 3번 입력하면 됩니다. 잘 되시나요?
우리는 Vim의 모달입력 모델과 싸우지 말고, 그것과 함께 작업을 하면서, 특정작업을 어떻게 하면 더 쉽게 할 수 있는지 살펴봐야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;대진왈 : 공개된 pdf파일 하나를 이제야 끝냈네요. 사실 번역은 어느정도 되어있는데, jekyll에 맞게 마크다운 형식으로 변경하면서 문장을 다시 읽어보고 제가 이해한 것을 토대로 다시 작성해서 원문에 의미를 충분히 잘 전달하고 있는지는 저도 의심스럽습니다. ^^. 다음 공개된 부분은 팁64매크로 부분이네요. 매일 조금씩 꾸준히 할깨요 ^^/ 즐거운 주말 되세요.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>일타이피</title>
      <link>https://daejinseok.github.io/post/2014-05-28-pvim-103-tip2-two_for_the_price_of_one/</link>
      <pubDate>Wed, 28 May 2014 00:00:01 +0900</pubDate>
      
      <guid>https://daejinseok.github.io/post/2014-05-28-pvim-103-tip2-two_for_the_price_of_one/</guid>
      <description>&lt;p&gt;원문 &lt;a href=&#34;http://media.pragprog.com/titles/dnvim/vim.pdf&#34;&gt;Practical Vim - The Vim Way&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;*A*명령은 두 동작을 &lt;em&gt;$a&lt;/em&gt; 하나의 키입력으로 합친 것이라고 말할 수 있습니다. 이처럼 동작하는 명령은 이것 하나만 있는 것이 아닙니다. Vim에는 두 개 이상의 명령을 압축한 복합명령들이 있습니다. 아래 표는 그 예를 몇 가지 보여줍니다. 혹시 공통점이 보이나요?&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;복합명령&lt;/th&gt;
&lt;th&gt;동등한 명령&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;c$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;cl&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;^C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;^i&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;$a&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;A&amp;lt;CR&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;ko&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;ko&lt;/em&gt;( 혹은 더 나쁘게 &lt;em&gt;k$a&amp;lt;CR&amp;gt;&lt;/em&gt;)를 입력한다면, 그만 사용하고, 무엇을 하고 있는지 생각을 해보면 *O*명령과 동일하다는 것을 알게 됩니다.&lt;/p&gt;

&lt;p&gt;이 명령들의 공통점은 전부는 노말모드에서 입력모드로 전환을 합니다. 이 공통점이 점명령에 어떤 영향을 주는지 한번 생각해보세요. ^^ 피스~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>팁2. 반복하지마세요.</title>
      <link>https://daejinseok.github.io/post/2014-05-28-pvim-102-tip2-dont_repeat_yourself/</link>
      <pubDate>Wed, 28 May 2014 00:00:00 +0900</pubDate>
      
      <guid>https://daejinseok.github.io/post/2014-05-28-pvim-102-tip2-dont_repeat_yourself/</guid>
      <description>

&lt;p&gt;원문 &lt;a href=&#34;http://media.pragprog.com/titles/dnvim/vim.pdf&#34;&gt;Practical Vim - Tip 2 Don&amp;rsquo;t Repeat Yourself&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;아래에 문장 끝에 세미콜론을 추가해야 되는 자바스크립트 코드가 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var foo = 1
var bar = &#39;a&#39;
var foobar = foo + bar
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;커서를 문장 끝으로 이동 ( $ )&lt;/li&gt;
&lt;li&gt;입력모드로 변경 ( a )&lt;/li&gt;
&lt;li&gt;세미콜론을 추가 ( ; )&lt;/li&gt;
&lt;li&gt;명령모드로 변경 ( ESC )&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같이 입력하면 첫 번째 문장문장 끝에 세미콜론을 추가할 수 있습니다. 그리고 나머지 두 줄은 간단히 아래와 같이 처리 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;아래로 이동 ( j )&lt;/li&gt;
&lt;li&gt;커서를 문장 끝으로 이동 ( $ )&lt;/li&gt;
&lt;li&gt;앞서 입력한 a; 명령 반복 ( . )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;개선의 여지가 없을까요 ?&lt;/p&gt;

&lt;h4 id=&#34;불필요한-이동-줄이기&#34;&gt;불필요한 이동 줄이기&lt;/h4&gt;

&lt;p&gt;a 명령은 현재의 커서 뒤에 내용을 추가하지만, &lt;strong&gt;&lt;em&gt;A 명령&lt;/em&gt;&lt;/strong&gt;은 라인 끝에 내용을 추가합니다. 다시 말해 A를 누르면 현재의 커서 위치에 상관없이 해당 라인의 끝으로 이동 후에 입력모드로 변환됩니다. 즉 $a를 하나의 키 입력으로 압축한 것입니다. ‘&lt;a href=&#34;../2014-05-28-pvim-103-tip2-two_for_the_price_of_one&#34;&gt;일타이피(Two for the Price of One)&lt;/a&gt;’에서 *A*와 같은 키조합을 참고하세요.&lt;/p&gt;

&lt;p&gt;앞 예제를 개선하면 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/pvim-002-tip2-1.png&#34; alt=&#34;점명령 A 예제&#34; /&gt;&lt;/p&gt;

&lt;p&gt;*$a*대신 *A*를 사용하면, 점명령에 날개를 달아주게 됩니다. 커서가 라인의 컬럼 위치에 상관없이 라인끝으로 이동하므로 변경할 라인만 확인 후 필요한 만큼 *j.*를 누르면 됩니다.&lt;/p&gt;

&lt;p&gt;이동하기 위해 &lt;em&gt;j&lt;/em&gt;, 실행하기 위해 &lt;em&gt;.&lt;/em&gt; 더 이상 좋은 방법은 없습니다. 앞으로 2개의 예제를 더 살펴볼 것이며, 이런 사용패턴을 지켜보시기 바랍니다.&lt;/p&gt;

&lt;p&gt;이와같이 간단한 예제에 대한 이런 방식은 좋아 보이지만, 보편적인 해결책은 아닙니다. 만약 50개의 연속 된 라인에 세미콜론을 추가해야 한다고 상상하면, 변경마다 *j.*를 누르는 것은 아주 짜증나는 작업으로 보이기 시작합니다. 이에 대한 또 다른 접근방법은 Tip30 에 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>팁1. 점명령을 만나다</title>
      <link>https://daejinseok.github.io/post/2014-05-27-pvim-101-tip1-meet_the_dot_command/</link>
      <pubDate>Tue, 27 May 2014 00:00:01 +0900</pubDate>
      
      <guid>https://daejinseok.github.io/post/2014-05-27-pvim-101-tip1-meet_the_dot_command/</guid>
      <description>

&lt;p&gt;원문 &lt;a href=&#34;http://media.pragprog.com/titles/dnvim/vim.pdf&#34;&gt;Practical Vim - Tip 1 Meet the Dot Command&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;점명령(Dot Command)은 마지막 변경을 반복합니다. 이것은 Vim에서 가장 강력하고 유용한 명령입니다.&lt;/p&gt;

&lt;p&gt;Vim의 도움말에서는 점명령을 단순히 “마지막 변경을 반복”이라고 적혀있습니다. 하지만 이와 같은 단순한 설명으로는 점명령의 핵심을 알 수 없습니다. 우선 변경이라는 것이 무엇인지 알아야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;마지막 변경&lt;/em&gt;&lt;/strong&gt;이라는 것은 하나의 문자를 변경하는 것일 수도 있고, 라인 전체, 혹은 파일 전체를 변경하는 것일 수도 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Line one
Line two
Line three
Line four
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x 명령은 커서 아래 문자를 삭제합니다. 여기에서 점명령을 사용하면 &lt;strong&gt;&lt;em&gt;마지막 변경&lt;/em&gt;&lt;/strong&gt;은 커서 아래 문자를 삭제하라고 말하는 것입니다. 변경한 것을 취소하기 위해 u 키를 여러 번 누르면 파일은 원래 상태로 돌릴 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/pvim-000-tip1-1.png&#34; alt=&#34;점명령 x 예제&#34; /&gt;&lt;/p&gt;

&lt;p&gt;dd 명령 또한 삭제를 수행하지만, 라인 전체를 삭제합니다. 만약 dd 입력한 후 점명령을 사용한다면 &lt;strong&gt;&lt;em&gt;마지막 변경&lt;/em&gt;&lt;/strong&gt;은 라인을 삭제하라고 지시하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/pvim-000-tip1-2.png&#34; alt=&#34;점명령 dd 예제&#34; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 &amp;gt;G 명령은 현재 라인에서 파일 끝까지 들여쓰기를 증가시킵니다. 만약 이 명령 뒤에 점명령이 따라온다면, &lt;strong&gt;&lt;em&gt;마지막 변경&lt;/em&gt;&lt;/strong&gt;은 현재 위치에서 파일 끝까지 들여쓰기를 증가시키도록 합니다. 예제에서는 차이점을 강조하기 위해 두 번째 라인에 커서를 두고 시작할 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/pvim-000-tip1-3.png&#34; alt=&#34;점명령 &amp;gt; 예제&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;점명령은-작은-매크로입니다&#34;&gt;점명령은 작은 매크로입니다.&lt;/h2&gt;

&lt;p&gt;x, dd 그리고 &amp;gt; 명령 모두 명령모드에서 실행되고, 점명령에 의해 &lt;strong&gt;&lt;em&gt;마지막 변경&lt;/em&gt;&lt;/strong&gt;이 반복되었습니다. 하지만 &lt;strong&gt;&lt;em&gt;마지막 변경&lt;/em&gt;&lt;/strong&gt;에 대한 더 정확한 의미는 입력모드로 들어가는 순간부터 명령모드로 돌아오기까지 변경을 의미합니다. 따라서 점명령은 앞서 보여드린 명령 반복 외에 입력모드에서 명령모드로 돌아오기까지 변경을 기록한 것을 반복할 수 있는 작은 매크로입니다.&lt;/p&gt;

&lt;h2 id=&#34;주의&#34;&gt;주의&lt;/h2&gt;

&lt;p&gt;책을 읽고 제가 이해한 것을 적은 글입니다. 원문과는 차이가 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;수정이력&#34;&gt;수정이력&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2014.05.27 최초작성&lt;/li&gt;
&lt;li&gt;2016.08.14 맞춤법 및 주의 추가&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>1장. Vim으로 가는 길</title>
      <link>https://daejinseok.github.io/post/2014-05-27-pvim-100-ch1/</link>
      <pubDate>Tue, 27 May 2014 00:00:00 +0900</pubDate>
      
      <guid>https://daejinseok.github.io/post/2014-05-27-pvim-100-ch1/</guid>
      <description>

&lt;p&gt;원문 &lt;a href=&#34;http://media.pragprog.com/titles/dnvim/vim.pdf&#34;&gt;Practical Vim - The Vim Way&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;텍스트 작업은 수정할 곳을 반복적으로 이동하며, 반복적인 변경을 많이 합니다. 이런 반복되는 작업을 효과적으로 할 수 있다면 많은 시간을 절약할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Vim은 이런 반복에 최적화되어 있습니다. Vim은 최근에 한 작업을 기억하고 있으며, 한 번의 키입력으로 언제나 재실행할 수 있습니다. 이 말은 강력하게 들리지만, 유용한 반복 단위를 만드는 방법을 배우지 않는 한 별로 쓸모가 없습니다. 이런 개념을 익히는 것은 효과적인 Vim을 다루기 위한 열쇠입니다.&lt;/p&gt;

&lt;p&gt;점명령(dot command). 그냥 보기에는 단순한 이 명령은 Vim에서 가장 유용한 도구이며, Vim를 숙달하기 위해서는 가장 먼저 이해해야 합니다. 점명령을 사용하여 처리할 수 있는 간단한 편집 작업 몇 가지를 보여 줄 것입니다. 각각의 작업은 다른 작업과는 다르게 보이지만 해결방법은 거의 같습니다. 하나의 키로 해당위치로 움직이고, 반복을 실행하기 위해 또 다른 하나의 키만 필요하다는 것을 보여 줄 것입니다.&lt;/p&gt;

&lt;h2 id=&#34;주의&#34;&gt;주의&lt;/h2&gt;

&lt;p&gt;책을 읽고 제가 이해한 것을 적은 글입니다. 원문과는 차이가 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;수정이력&#34;&gt;수정이력&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2014.05.27 최초작성&lt;/li&gt;
&lt;li&gt;2016.08.14 맞춤법 수정, 주의 추가&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>